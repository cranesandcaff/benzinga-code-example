/**
 * @module Portfolio
 * @description Portfolio Factory returns the Portfolio object. In AngularJS a factory returns a value.
 * The portfolio object contains the users balance, their owned stock in an array under the owned property
 * and has the methods for interacting with itself.
 * @requires lodash
 * @requires $http
 * @requires FlashService
 * @requires $sessionStorage
 * @returns Portfolio Object
 */
angular.module('benzingaStockExchangeApp')
  .factory('Portfolio', function ($http, $sessionStorage, FlashService) {
    return {
      /**
       * Initialize with a balance of 100,000
       * @property {number}  balance - The current balance in the users portfolio.
       */
      balance: 100000,
      /**
       * On init we are not viewing anything so this is set to false so that it hides the template.
       * There isn't a method to hide the method except on page reload. I couldn't really imagine
       * a scenario where it needed to be cleared or what would replace it.
       * @property {number | object}  potential - Either false on init or the current Stock being considered.
       * @default 100000
       */
      potential: false,
      /**
       * The array for owned stock to be placed in.
       * @property {array} owned Array of currently owned stock.
       */
      owned: [],
      /**
       * @this Portfolio
       * @description Check if there is anything in session storage under the name space. Uses lodash to {@link http://lodash.com/docs#merge|merge} the existing portfolio if it exists into
       */
      init: function(){
        var existingPortfolio = $sessionStorage.portfolio;
        _.merge(this, existingPortfolio);
      },
      /**
       * Use the ngStorage module and sessionStorage object to store the balance and stock owned.
       * Nothing else really needs to be serialized, unless we want to store the last stock watched.
       */
      store: function(){
        var portfolio = _.pick(this, ['balance', 'owned']);
        $sessionStorage.portfolio = portfolio;
      },
      /**
       * Use Angulars $http service to get stock data from Benzinga API
       * @param {string} sym Stock symbol user is searching for.
       * @this Portfolio
       * We bind the found portfolio the potential property of the PortfolioFactory
       */
      search: function(sym){
        return $http.get('http://data.benzinga.com/stock/' + sym).success(function(res){
          if(res.status === 'error'){
            FlashService.show('error', 'No results for that symbol, try again?');
          } else {
            this.potential = res;
          }
        }.bind(this));
      },
      /**
       * This calculates the Value Weighted Average Price
       * @param {object} stock The stock we are averaging the price for.
       * @description An {@link http://jsperf.com/jquery-foreach-vs-for/8|optimized for loop} iterates over the transaction history
       * It sums the transacted quantity into the stockMoved variable in order to divide over it later in the method
       * The average price is generated by adding the result of each transactions quanity by the price paid that time
       * The total amount of stock is generated by first checking to see if the transaction was a purchase
       * If it was we simply add the quantity, if it was not then it had we add the negative of the quantity.
       * It also sets the quantity on the stock object.
       * @returns the sum of the average price divided by the total amount of stock moved.
       */
      vwap: function(stock){
        var averagePrice = 0, totalStock = 0, stockMoved = 0;
        for (var i = 0, len = stock.transactionHistory.length; i < len; i++) {
            function transact(transaction){
              stockMoved   += transaction.quantity;
              averagePrice += transaction.quantity * parseFloat(transaction.price);
              totalStock   += transaction.purchase ? transaction.quantity : -transaction.quantity;
            }
            transact(stock.transactionHistory[i]);
        }
        stock.quantity = totalStock;
        return averagePrice / stockMoved;
      },
      /**
       * @param {object} stock The stock we are performing a transaction on.
       * @param {number} quantity Quantity specified in transaction
       * @param {bool} purchase Indicates which direction the transaction is going in.
       * @description Private function used by the Portfolio object.
       * We check to see if the stock symbol exists in Portfolio.owned array using lodash's {@link http://lodash.com/docs#some | some method}, if it exists we select it from the array.
       * If it does not exist we create a transactionHistory property as an empty array, we also push the transaction into Portfolio.owned
       * Once we have our stock object with the transactionHistory array we push the quantity, current asking price and the purchase boolean
       * into that array, finally we call the Portfolio.vwap function and assign the resulting Value Weighted Average Price to the vwap property of the stock object.
       */
      transaction: function(stock, quantity, purchase){
        var currentlyOwned = _.some(this.owned, {symbol: stock.symbol});
        if(currentlyOwned){
          stock = _.find(this.owned, stock);
        } else {
          stock.transactionHistory = [];
          this.owned.push(stock);
        }
        stock.transactionHistory.push({quantity: quantity, price: stock.ask, purchase: purchase});
        stock.vwap = this.vwap(stock);
      },
      /**
       * @param {object} stockDetails The details of the stock object.
       * @param {number} quantity Quantity specified in transaction
       * @description Public function used in controller. We create a new object by using lodash's {@link http://lodash.com/docs#pick|pick} method to select the stock symbol, name, asking and bidding price.
       * The remaining information from the API is assigned to a details property on the stock object, in case it is needed in the future. We create the new object to help prevent API changes from causing future breakages. An unversioned API and lack of control over it still leaves the app very vulnerable to third party changes.
       * If the balance following the transaction would be less than 0 we use the {@link module:FlashService|FlashService} to create an error message.
       * Following a successful transaction we run the Portfolio.store() method to save the portfolio to sessionStorage         .
       */
      buy: function(stockDetails, quantity){
        var stock = _.pick(stockDetails, ['symbol', 'name', 'ask', 'bid']);
        stock.details = stockDetails;
        var transactionTotal = stock.ask * quantity;
        var postBalance = this.balance - transactionTotal;
        if(postBalance > 0){
          this.transaction(stock, quantity, true);
          this.balance = postBalance;
          this.store();
        } else {
          FlashService.show('error', 'You don\'t have enough money to purchase this amount.');
        }
      },
      /**
       * @param {object} stockDetails The details of the stock object.
       * @param {number} quantity Quantity specified in transaction
       * @description Public function used in controller.
       * We need to check that the user owns the stock they intend to sell, after that we need to check that they have enough stock to sell the amount in question.
       * This is somewhat duplicative, as the transaction method also checks to see if the stock is owned. I considered some solutions to decrease this duplication
       * however nothing really struck out as a way to reduce this duplication, at least not in the timeframe I wanted to finish the project in.
       * We flash an error message if they don't have enough of the stock or if they don't own the stock at all.
       * Following a successful transaction we run the Portfolio.store() method to save the portfolio to sessionStorage.
       */
      sell: function(stockDetails, quantity){
        var transactionTotal = stockDetails.bid * quantity;
        var currentlyOwned = _.some(this.owned, {symbol: stockDetails.symbol});
        if(currentlyOwned){
          var stock = _.find(this.owned, {symbol: stockDetails.symbol});
          var postBalance = this.balance + transactionTotal;
          var postQuantity = stock.quantity - quantity;
          if(postQuantity >= 0){
            this.transaction(stock, quantity, false);
            if(stock.quantity <= 0){
              _.remove(this.owned, stock);
            }
            this.balance = postBalance;
            this.store();
          } else {
            FlashService.show('error', 'You don\'t have that much stock to sell.');
          }
        } else {
          FlashService.show('error', 'You don\'t own that stock.');
        }
      }
    };
  });
